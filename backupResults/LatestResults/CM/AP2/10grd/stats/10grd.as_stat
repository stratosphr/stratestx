Abstract States (13 in 00:00:03.811):

q2 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), (p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q18 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), (p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), (p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q32 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q33 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), (p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q44 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), (p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), (p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q64 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), (p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q128 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), (p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q130 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), (p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), (p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q144 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), (p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), (p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q146 = ¬(p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), (p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), ¬(p4 = Status=on[1]), (p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), (p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q556 = (p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), ¬(p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), (p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), (p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q812 = (p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), (p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), ¬(p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), (p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), (p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))
q864 = (p0 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 50))), (p1 = and(Status=on[1], AskChange=0, AskCof=0, MaxBal >= (Balance + 100))), ¬(p2 = and(Status=off[0], CofLeft > 0, MaxPot >= Pot)), (p3 = or(and(Status=on[1], AskChange=0, AskCof=0, Balance=0), Status=error[2])), (p4 = Status=on[1]), ¬(p5 = and(Status=off[0], Pot >= (MaxPot - 50))), ¬(p6 = and(Status=on[1], Balance >= 50, AskCof=0, AskChange=0)), ¬(p7 = and(Status=on[1], Balance > 0, AskCof=0, AskChange=0)), ¬(p8 = ∃(x).(and(and(x ∈ [1..MaxCof]), and(MaxCof >= (CofLeft + x), Status=off[0], MaxCof > CofLeft)))), ¬(p9 = and(Status=on[1], Balance >= 50, AskCof=1, CofLeft > 0))